<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <link rel="shortcut icon" type="image/x-icon" href="images/favicon.ico" />
    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Ragout - usage instructions</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Ragout</h1>
          <h2>Chromosome assembly using multiple references</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/fenderglass/Ragout/zipball/master" id="download-zip" class="button"><span>Latest source</span></a>
          <a href="https://github.com/fenderglass/Ragout/releases" id="download-tar-gz" class="button"><span>Releases</span></a>
          <a href="https://github.com/fenderglass/Ragout" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">

<h1><a id="Usage_Instructions_for_Ragout_0"></a>Usage Instructions for Ragout</h1>
<h2><a id="Quick_Usage_3"></a>Quick Usage</h2>
<pre><code>usage: ragout.py [-h] [-o output_dir] [-s {sibelia,hal}]
                 [--no-refine] [--overwrite] [--repeats] [--debug]
                 [-t THREADS] [--version]
                 recipe_file


positional arguments:
  recipe_file           path to recipe file

optional arguments:
  -h, --help            show this help message and exit

  -o output_dir, --outdir output_dir
                        path to the working directory (default: ragout-out)

  -s {sibelia,hal}, --synteny {sibelia,hal}
                        backend for synteny block decomposition (default:
                        sibelia)

  --refine              enable refinement with assembly graph (default:
                        False)

  --solid-scaffolds     do not break input sequences - disables chimera
                        detection module (default: False)

  --overwrite           overwrite results from the previous run (default: False)

  --repeats             enable repeat resolution algorithm (default: False)

  --debug               enable debug output (default: False)

  -t THREADS, --threads THREADS
                        number of threads for synteny backend (default: 1)

  --version             show program's version number and exit
</code></pre>
<h2><a id="Examples_43"></a>Examples</h2>
<p>You can try Ragout on the provided ready-to-use examples:</p>
<pre><code>./ragout.py examples/E.Coli/ecoli.rcp --outdir examples/E.Coli/out/ --refine
./ragout.py examples/H.Pylori/helicobacter.rcp --outdir examples/H.Pylori/out/ --refine
./ragout.py examples/S.Aureus/aureus.rcp --outdir examples/S.Aureus/out/ --refine
./ragout.py examples/V.Cholerae/cholerae.rcp --outdir examples/V.Cholerae/out/ --refine
</code></pre>
<h2><a id="Algorithm_Overview_54"></a>Algorithm Overview</h2>
<p>Ragout first uses <em>Sibelia</em> or <em>HAL alignment</em> for to decompose the input
genomes into the sequences of synteny blocks – this step is usually
the most time-consuming.</p>
<p>Using the synteny information, Ragout infers the phylogenetic tree
of the input genomes (if it is not given as input).
Next, Ragout constructs the breakpoint graph (which reflects adjacencies
between the synteny blocks in the input genomes) and recovers the missing adjacencies
in the target genome (as it is fragmented, some adjacencies are missing).
Then, assembly fragments are joined into scaffolds. The final
chromosomes are constructed as a consensus of scaffolds built
with different synteny block scales.</p>
<p>Finally, an optional refinement step is performed. Ragout reconstructs
assembly (overlap) graph from the assembly fragments and uses
this graph to insert very short/repetitive fragments into the
assembly.</p>
<h2><a id="Input_76"></a>Input</h2>
<p>Ragout takes as input:</p>
<ul>
<li>Reference genomes [in <em>FASTA</em> format or packed into <em>HAL</em>]</li>
<li>Target assembly in [in <em>FASTA</em> format or packed into <em>HAL</em>]</li>
</ul>
<p>Optionally, you can add:</p>
<ul>
<li>Phylogenetic tree with the reference and target genomes [in <em>NEWICK</em> format]</li>
<li>Synteny block scale</li>
</ul>
<p>All these parameters should be described in a single recipe file (see below)</p>
<h2><a id="Output_92"></a>Output</h2>
<p>After running Ragout, output directory will contain:</p>
<ul>
<li><strong>target_scaffolds.fasta</strong>: scaffolds</li>
<li><strong>target_unplaced.fasta</strong>: unplaced input sequences</li>
<li><strong>target_scaffolds.links</strong>: the order and orientation of the input sequences in scaffolds (see below)</li>
<li><strong>target_scaffolds.agp</strong>: same as below, but in NCBI AGP format</li>
</ul>
<h2><a id="Recipe_File_103"></a>Recipe File</h2>
<p>A recipe file describes the Ragout run configuration.
Here is an example of such file (full version, some parameters could be ommited):</p>
<pre><code>.references = rf122,col,jkd,n315
.target = usa

col.fasta = references/COL.fasta
jkd.fasta = references/JKD6008.fasta
rf122.fasta = references/RF122.fasta
n315.fasta = references/N315.fasta
usa.fasta = usa300_contigs.fasta

.tree = (rf122:0.02,(((usa:0.01,col:0.01):0.01,jkd:0.04):0.005,n315:0.01):0.01);
.blocks = small
.naming_ref = rf122
</code></pre>
<p>or, if using <em>HAL</em> as input, tree, blocks scale and naming reference are inferred automatically</p>
<pre><code>.references = miranda,simulans,melanogaster
.target = yakuba
.hal = genomes/alignment.hal
</code></pre>
<p><h3>Parameters description:</h3></p>
<p>Each parameter could be “global” (related to the run) or “local” (for a particular genome).
Global parameters start from dot:</p>
<pre><code>.global_param_name = value
</code></pre>
<p>To set local parameter, use:</p>
<pre><code>genome_name.param_name = value
</code></pre>
<p><h3>Global parameters</h3></p>
<ul>
<li><strong>references</strong>: comma-separated list of reference names [<em>required</em>]</li>
<li><strong>target</strong>: target genome name [<em>required</em>]</li>
<li><strong>tree</strong>: phylogenetic tree in NEWICK format</li>
<li><strong>blocks</strong>: synteny blocks scale</li>
<li><strong>hal</strong>: path to the alignment in <em>HAL</em> format</li>
<li><strong>naming_ref</strong>: reference to use for output scaffolds naming</li>
</ul>
<p><h3>Local parameters</h3></p>
<ul>
<li><strong>fasta</strong>: path to <em>FASTA</em> [default = not set]</li>
<li><strong>draft</strong>: indicates that reference is in a draft form (not chromosomes) [default = false]</li>
</ul>
<p><h3>Default values</h3></p>
<p>You can change default values of the local parameters by assigning the
parameter value to the special “star” object:
for instance, if all input references except one are in a draft form, you can write:</p>
<pre><code>*.draft = true
complete_ref.draft = false
</code></pre>
<p><h3>Quick comments</h3></p>
<p>Paths to <em>FASTA</em>/<em>HAL</em> can be both relative and absolute.</p>
<p>If you use <em>Sibelia</em> for synteny blocks decomposition you must specify
FASTA for each input genome. If you use <em>HAL</em>, all sequences will be taken from it.</p>
<p><em>Sibelia</em> requires all sequence headers (&quot;&gt;gi…&quot;)
among ALL <em>FASTA</em> files to be unique.</p>
<p>If you do not specify phylogenetic tree or synteny block scale,
they will be inferred automatically.</p>
<h2><a id="Parameters_Description_178"></a>Parameters Description</h2>
<h3><a id="Phylogenetic_tree_181"></a>Phylogenetic tree</h3>
<p>Ragout algorithm requires a phylogenetic tree as input. This tree
could be inferred automatically from the breakpoint configuration
of the input genomes. The automatic inference
generally produces a good approximation of a real phylogeny
and is therefore recommended for most of the purposes.
However, if you already have the tree structure from a different source,
you may guide the algorithm with it by setting the corresponding parameter.</p>
<h3><a id="Synteny_block_scale_192"></a>Synteny block scale</h3>
<p>Because the decomposition procedure is parameter-dependent, the assembly
is performed in multiple iterations with different synteny block
scale. Intuitively, the algorithm firstly considers only fragments
that are long enough and then insert shorter ones into final scaffolds.</p>
<p>There are two pre-defined scales: “small” and “large”. We recommend
“small” for relatively small genomes (bacterial) and large otherwise
(mammalian). If the parameter is not set, it is automatically inferred
based on input genomes size (recommended).</p>
<h3><a id="Reference_genome_in_draft_form_205"></a>Reference genome in draft form</h3>
<p>Ragout can use an incomplete assembly (contigs/scaffolds) as a reference.
In such a case you should specify that the reference is in draft from by
setting the corresponding parameter in the recipe file.</p>
<h3><a id="Naming_reference_212"></a>Naming reference</h3>
<p>Output scaffolds will be named according to a homology to one of the input
references (naming reference). This reference can be set with the corresponding
recipe parameter, otherwise it will be chosen as the closest reference in the
phylogenetic tree. The naming pattern is as follows. If a scaffold is homologous
to a single reference chromosome “A”, it will be named as “chr_A”. If there
are multiple homologous chromosomes, for example “A” and “B” (in case of
chromosomal fusion), it will be named “chr_A_B”. If there are multiple
scaffolds with a same name, the longest one would be chosen as primary,
others will get an extra “_unlocalized” suffix.</p>
<h2><a id="Synteny_Backends_225"></a>Synteny Backends</h2>
<p>Ragout has two different options for synteny block decomposition:</p>
<ul>
<li>Decomposition with <em>Sibelia</em></li>
<li>HAL alignment produced by Progressive Cactus</li>
</ul>
<p>You can choose between backends by specifying --synteny (-s) option.</p>
<h3><a id="Sibelia_236"></a>Sibelia</h3>
<p>“Sibelia” is the default option and recommended for bacterial genomes.</p>
<h3><a id="Whole_genome_alignment_in_HAL_format_240"></a>Whole genome alignment in <em>HAL</em> format</h3>
<p>Alternatively, Ragout can use <em>HAL</em> whole genome alignment for synteny blocks
decomposition. This option is recommended for large (over 100MB) genomes, which
<em>Sibelia</em> can not process. This alignment is done by Progressive Cactus
aligner [<a href="https://github.com/glennhickey/progressiveCactus">https://github.com/glennhickey/progressiveCactus</a>]. Currently, we do not
provide bindings for running Progressive Cactus from Ragout, as the procedure
might vary for different setups. Ragout starts with the alignment
result in <em>HAL</em> format, <em>HAL tools</em> should be installed in your system.</p>
<h3><a id="MAF_backend_is_deprecated_251"></a>MAF backend is deprecated</h3>
<p>The support of MAF synteny backend is deprecated, because it is more
convenient to work directly with <em>HAL</em>, which is a default output of
Progressive Cactus.</p>
<h2><a id="Repeat_Resolution_258"></a>Repeat Resolution</h2>
<p>As the main Ragout algorithm works only with unique synteny blocks, we filter
all repetitive blocks before building the breakpoint graph. Therefore, some
target sequences (generally, short and repetitive contigs) will be ignored
(some of them could be put back during the refinement step below).</p>
<p>To incorporate these repetitive fragments into the assembly, you can
use the optional algorithm, which tries to resolve the repetitive contigs
and find their positions in the assembly (’–repeats’ option). Depending
on the dataset, you may get a significant increase in the assembly
coverage, therefore decreasing scaffolds gaps. However, if there are copy number
variations between the reference and target genomes, the algorithm could make
some false insertions.</p>
<h2><a id="Chimera_Detection_275"></a>Chimera Detection</h2>
<p>Ragout detects chimeric adjacencies inside the input sequences and fixes
them by breaking the sequences into parts. The chimera detection algorithm
tries to distinguish such erroneous joins from target-specific adjacencies,
that are not observed in the references. By default, the adjacency which is
not supported by references is considered chimeric, unless there is an
evidence of a rearrangement in the target genome. Sometimes, due to the
fragmentation of the target genome, the evidence support is missing.
If you have high quality contigs/scaffolds,
you may choose to turn chimera detection off by specifying ‘–solid-scaffolds’ option.</p>
<h2><a id="Refinement_with_the_Assembly_Graph_289"></a>Refinement with the Assembly Graph</h2>
<p>Ragout optionally uses assembly (overlap) graph to incorporate very short / repetitive
contigs into the assembly (’–refine’ option). First, this graph is reconstructed by overlapping
input contigs/scaffolds. Then current Ragout scaffolds are “threaded”
through this graph to find the true “genome path”.
This procedure increases number of contigs in output scaffolds and also
improves the scaffold gaps estimates. Sometimes assembly graphs are not very accurate,
which may lead to incorrectly inserted contigs. However, for the most bacterial
assemblies the fraction of errors should be minor. This procedure is generally recommended
for bacterial assemblies, however, the effect is usually minor for large genomes
because of complications with assembly graph reconstruction.</p>
<h2><a id="Links_File_304"></a>Links File</h2>
<p>Ragout outputs information about generated adjacencies in “*.links” file.
It is organized as a table for each scaffold with the values below:</p>
<ul>
<li><strong>sequence</strong> : input fragment’s name and strand (possibly with coordinates in form [start:end])</li>
<li><strong>start</strong> : fragment’s position in the scaffold</li>
<li><strong>length</strong> : fragment’s length</li>
<li><strong>gap</strong> : gap size between the current and the next fragment</li>
<li><strong>support</strong> : reference support of the corresponding adjacency</li>
</ul>
<p>Input fragments are described in a form:</p>
<pre><code>[+/-]seq_name[start:end]
</code></pre>
<p>The sign corresponds to the fragment’s strand. The [start:end] structure is omitted
if the full fragment is used. A symbol “~&gt;” in support field corresponds to the
assembly graph support</p>
<h2><a id="Useful_Scripts_325"></a>Useful Scripts</h2>
<p>Scripts are located in “scripts” directory</p>
<p><strong>verify-order.py:</strong></p>
<p>Tests the correctness of the inferred contigs order if a “true” reference
is available. First, contigs should be mapped on that reference using
<em>nucmer</em> software:</p>
<pre><code>nucmer --maxmatch --coords reference contigs
</code></pre>
<p>Then run the script with the obtained “coords” file:</p>
<pre><code>scripts/verify-order.py nucmer_coords ord_file
</code></pre>

        </section>

        <footer>
          Ragout is maintained by <a href="https://github.com/fenderglass">fenderglass</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>